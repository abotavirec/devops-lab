# ---------- Trigger ----------
trigger:
  branches:
    include:
      - main

# ---------- Variables ----------
variables:
  # Service connection used by AzureCLI@2. Must have access to the subscription(s)
  # that contain both AKS and ACR.
  azureSubscription: 'sc-azure-rg-sw-web-dev-cac-01'

  # Fill these two from the AKS environment behind your old SC_AKS connection
  aksResourceGroup: 'rg-sw-web-dev-cac-01'
  aksClusterName: 'aks-web-dev-cac-01'

  # From ACR_LOGIN_SERVER = crwebdevcac01.azurecr.io  → acrName=crwebdevcac01
  acrName: 'crwebdevcac01'

  # From parameters.imageRepository in your old pipeline
  imageRepository: 'virecintelligencevirecwebapp'

  # If you don’t pass this when queueing, we’ll fall back to fallbackTag below
  imageTag: ''

  # Preserve your prior behavior
  fallbackTag: '14'

  # From parameters.deployNamespace
  k8sNamespace: 'default'

  # From K8S_DEPLOYMENT
  k8sDeploymentName: 'virec-web-app'

  # From CONTAINER_NAME (IMPORTANT: container name ≠ deployment name)
  k8sContainerName: 'main'

  # Match your previous final rollout wait
  kubectlCommandTimeout: '900s'

stages:
- stage: Deploy
  displayName: Deploy to AKS
  jobs:
    - job: Deploy
      displayName: Set image & rollout
      pool: { vmImage: 'ubuntu-latest' }
      steps:
      - task: AzureCLI@2
        displayName: 'Azure: get AKS credentials'
        inputs:
          azureSubscription: '$(azureSubscription)'
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail
            az aks install-cli
            az aks get-credentials -g "$(aksResourceGroup)" -n "$(aksClusterName)" --overwrite-existing

      # Resolve which tag to deploy: prefer imageTag if provided; else fallbackTag.
      # Also verifies the tag exists in ACR before attempting the rollout.
      - task: AzureCLI@2
        displayName: 'Resolve and verify image tag'
        inputs:
          azureSubscription: '$(azureSubscription)'
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail
            ACR_NAME="$(acrName)"
            REPO="$(imageRepository)"
            CHOSEN_TAG="$(imageTag)"
            if [ -z "$CHOSEN_TAG" ]; then
              CHOSEN_TAG="$(fallbackTag)"
              echo "imageTag not provided; falling back to $(fallbackTag)"
            fi

            echo "Checking existence of $REPO:$CHOSEN_TAG in ACR $ACR_NAME..."
            COUNT=$(az acr repository show-tags -n "$ACR_NAME" --repository "$REPO" --query "[?@=='$CHOSEN_TAG'] | length(@)" -o tsv || echo 0)
            if [ "$COUNT" != "1" ]; then
              echo "##vso[task.logissue type=error]Tag '$CHOSEN_TAG' not found in ACR '$ACR_NAME' repo '$REPO'."
              echo "Available tags (head):"
              az acr repository show-tags -n "$ACR_NAME" --repository "$REPO" --top 20 -o tsv || true
              exit 2
            fi

            echo "##vso[task.setvariable variable=RESOLVED_TAG]$CHOSEN_TAG"
            echo "Resolved tag: $CHOSEN_TAG"

      - script: |
          set -euo pipefail
          FULL_IMAGE="$(acrName).azurecr.io/$(imageRepository):$(RESOLVED_TAG)"
          echo "Deploying image: $FULL_IMAGE"
          kubectl -n $(k8sNamespace) set image deployment/$(k8sDeploymentName) $(k8sContainerName)="$FULL_IMAGE" --record
          kubectl -n $(k8sNamespace) rollout status deployment/$(k8sDeploymentName) --timeout=$(kubectlCommandTimeout)
        displayName: 'kubectl set image + rollout status'

      # Optional: quick RBAC sanity (uncomment if helpful)
      # - script: |
      #     kubectl auth can-i patch deployment -n $(k8sNamespace)
      #   displayName: 'RBAC: can-i patch deployment'
