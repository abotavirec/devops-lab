trigger: none

resources:
  containers:
    - container: app
      type: ACR
      azureSubscription: 'ARM_SERVICE_CONNECTION'
      resourceGroup: rg-sw-web-dev-cac-01
      registry: crwebdevcac01
      repository: virecintelligencevirecwebapp
      trigger:
        enabled: true
        tags: { include: [ '*' ] }

# Optional: allow a manual tag when you run the pipeline manually
parameters:
- name: manualTag
  displayName: "Tag to deploy (manual runs)"
  type: string
  default: ""

variables:
  AKS_RG: rg-sw-web-dev-cac-01
  AKS_NAME: aks-web-dev-cac-01
  NAMESPACE: default
  DEPLOYMENT_NAME: webapp
  CONTAINER_NAME: web
  ACR_LOGIN_SERVER: crwebdevcac01.azurecr.io
  IMAGE_REPOSITORY: virecintelligencevirecwebapp

stages:
- stage: Deploy
  displayName: Deploy image to AKS
  jobs:
  - job: rollout
    displayName: Update Deployment and wait for rollout
    pool: { vmImage: 'ubuntu-latest' }
    steps:
    - task: AzureCLI@2
      displayName: Set image and rollout
      inputs:
        azureSubscription: 'ARM_SERVICE_CONNECTION'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail

          echo "==> Get AKS credentials"
          az aks get-credentials -g "$(AKS_RG)" -n "$(AKS_NAME)" --overwrite-existing

          # Resolve the image tag:
          # 1) ACR-triggered tag from resources (IMAGE_TAG env)
          # 2) manual override (MANUAL_TAG env)
          # 3) otherwise, fail loudly
          TAG="${IMAGE_TAG:-${MANUAL_TAG:-}}"
          if [ -z "$TAG" ]; then
            echo "ERROR: No image tag provided."
            echo " - If this pipeline was manually run, supply a tag via the 'manualTag' parameter."
            echo " - If triggered by ACR, ensure the container resource is configured and the run came from a new image push."
            exit 1
          fi

          FULL_IMAGE="$(ACR_LOGIN_SERVER)/$(IMAGE_REPOSITORY):${TAG}"
          echo "==> Using image: ${FULL_IMAGE}"

          # Create namespace only if not default (you can remove this block if you always use default)
          if [ "$(NAMESPACE)" != "default" ]; then
            kubectl create namespace "$(NAMESPACE)" --dry-run=client -o yaml | kubectl apply -f -
          fi

          kubectl -n "$(NAMESPACE)" set image "deployment/$(DEPLOYMENT_NAME)" \
            "$(CONTAINER_NAME)=${FULL_IMAGE}"

          echo "==> Waiting for rollout"
          kubectl -n "$(NAMESPACE)" rollout status "deployment/$(DEPLOYMENT_NAME)"

          echo "==> Current image:"
          kubectl -n "$(NAMESPACE)" get deploy "$(DEPLOYMENT_NAME)" \
            -o jsonpath='{.spec.template.spec.containers[?(@.name=="'$(CONTAINER_NAME)'")].image}'; echo
      # Map variables safely into env (this avoids $(...) macro tokens inside the script)
      env:
        IMAGE_TAG: $[ resources.containers['app'].tag ]   # present on ACR-triggered runs
        MANUAL_TAG: ${{ parameters.manualTag }}           # present on manual runs
