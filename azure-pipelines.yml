# ---------- CI & PR Triggers ----------
trigger:
  branches:
    include: [ main ]
pr:
  branches:
    include: [ main ]

# ---------- Parameters ----------
parameters:
  - name: imageRepository
    type: string
    default: 'virecintelligencevirecwebapp'     # ACR repo name
  - name: manifestPath
    type: string
    default: 'k8s/deployment.yaml'
  - name: applyManifest
    type: boolean
    default: true
  - name: fallbackTag
    type: string
    default: '14'                               # <-- existing tag in your ACR
  - name: deployNamespace
    type: string
    default: 'default'

# ---------- Variables ----------
variables:
  SYSTEM_DEBUG: true
  ACR_LOGIN_SERVER: 'crwebdevcac01.azurecr.io'
  K8S_DEPLOYMENT: 'virec-web-app'
  CONTAINER_NAME: 'main'
  SC_AKS:   'sc-aks-web-dev-cac-01'             # Kubernetes service connection (AKS)
  SC_AZURE: 'sc-azure-rg-sw-web-dev-cac-01'     # Azure RM service connection (ACR sub)

# ======================= STAGES =======================
stages:

# -------------------- BUILD & PUSH --------------------
- stage: Build
  displayName: Build & Push Image
  jobs:
    - job: DockerBuild
      displayName: Docker buildx + push to ACR
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - checkout: self
          fetchDepth: 0

        # Use commit SHA as the canonical image tag
        - bash: |
            set -euo pipefail
            echo "##vso[task.setvariable variable=IMAGE_TAG;isOutput=true]$(Build.SourceVersion)"
            echo "Resolved IMAGE_TAG=$(Build.SourceVersion)"
          name: setvars
          displayName: 'Set IMAGE_TAG to commit SHA'

        - bash: |
            set -euo pipefail
            if ! command -v jq >/dev/null 2>&1; then
              sudo apt-get update
              sudo apt-get install -y jq
            fi
          displayName: 'Ensure jq is installed'

        - task: AzureCLI@2
          displayName: 'Azure: login & ACR health / docker login (AAD token)'
          inputs:
            azureSubscription: '$(SC_AZURE)'
            scriptType: bash
            scriptLocation: inlineScript
            inlineScript: |
              set -euo pipefail
              set -x
              ACR_FQDN="$(ACR_LOGIN_SERVER)"      # e.g. crwebdevcac01.azurecr.io
              ACR_NAME="${ACR_FQDN%%.*}"          # e.g. crwebdevcac01

              echo "== Az account =="
              az account show -o table

              echo "== ACR health =="
              az acr check-health --name "$ACR_NAME" --yes || true

              echo "== Get AAD token & docker login =="
              TOKEN_JSON=$(az acr login --name "$ACR_NAME" --expose-token -o json)
              echo "$TOKEN_JSON" | jq -r '. | {username, accessToken}'
              USERNAME=$(echo "$TOKEN_JSON" | jq -r '.username')
              PASSWORD=$(echo "$TOKEN_JSON" | jq -r '.accessToken')
              echo "$PASSWORD" | docker login "$ACR_FQDN" -u "$USERNAME" --password-stdin
              docker info || true
              set +x

        # --- Smoke push proves auth/network BEFORE real build ---
        - bash: |
            set -euo pipefail
            ACR_FQDN="$(ACR_LOGIN_SERVER)"
            REPO='${{ parameters.imageRepository }}'
            PROBE="probe-$(Build.BuildId)"
            echo "== Smoke push: $ACR_FQDN/$REPO/alpine-test:$PROBE =="
            docker pull alpine:3.20
            docker tag alpine:3.20 "$ACR_FQDN/$REPO/alpine-test:$PROBE"
            docker push "$ACR_FQDN/$REPO/alpine-test:$PROBE"
          displayName: 'Smoke test: docker push to ACR (alpine)'

        - bash: |
            set -euo pipefail
            export BUILDKIT_PROGRESS=plain
            ACR="${ACR_LOGIN_SERVER}"
            REPO='${{ parameters.imageRepository }}'
            TAG='$(setvars.IMAGE_TAG)'

            echo "Preparing buildx..."
            docker buildx version || true
            if ! docker buildx inspect builder >/dev/null 2>&1; then
              docker buildx create --name builder --use
            else
              docker buildx use builder
            fi
            docker buildx inspect --bootstrap

            echo "== buildx build & push ($ACR/$REPO:$TAG and :latest) =="
            set +e
            docker buildx build \
              --push \
              --platform linux/amd64 \
              -t "$ACR/$REPO:$TAG" \
              -t "$ACR/$REPO:latest" \
              . 2>&1 | tee buildx.log
            BX_RC=${PIPESTATUS[0]}
            set -e

            if [[ $BX_RC -ne 0 ]]; then
              echo "buildx failed with code $BX_RC â€” falling back to classic docker build/push"
              docker build -t "$ACR/$REPO:$TAG" -t "$ACR/$REPO:latest" . 2>&1 | tee build_classic.log
              docker push "$ACR/$REPO:$TAG"   2>&1 | tee push_tag.log
              docker push "$ACR/$REPO:latest" 2>&1 | tee push_latest.log
            fi
          displayName: 'Build & push image (SHA + latest, with fallback)'

        - task: PublishBuildArtifacts@1
          displayName: 'Publish build logs (always)'
          condition: always()
          inputs:
            PathtoPublish: '$(System.DefaultWorkingDirectory)'
            ArtifactName: 'build-logs'
            publishLocation: 'Container'

        - task: Bash@3
          name: publish_meta
          displayName: 'Publish image metadata'
          inputs:
            targetType: inline
            script: |
              set -euo pipefail
              echo "repo=${{ parameters.imageRepository }}"     > image_meta.env
              echo "tag=$(setvars.IMAGE_TAG)"                  >> image_meta.env
              echo "registry=$(ACR_LOGIN_SERVER)"              >> image_meta.env
              cat image_meta.env

        - publish: $(System.DefaultWorkingDirectory)/image_meta.env
          artifact: image_meta

# ----------------------- DEPLOY -----------------------
- stage: Deploy
  displayName: Deploy to AKS
  dependsOn: Build
  jobs:
    - job: DeployAKS
      displayName: Apply manifest & set image
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - download: current
          artifact: image_meta

        # Decide which tag to deploy: SHA if present, else fallbackTag
        - task: AzureCLI@2
          displayName: 'Resolve deploy tag (prefer SHA, else fallback)'
          inputs:
            azureSubscription: '$(SC_AZURE)'
            scriptType: bash
            scriptLocation: inlineScript
            inlineScript: |
              set -euo pipefail
              source "$(Pipeline.Workspace)/image_meta/image_meta.env"
              ACR_NAME="${registry%%.*}"
              REPO="$repo"
              SHA_TAG="$tag"
              FALLBACK='${{ parameters.fallbackTag }}'

              echo "Checking for $REPO:$SHA_TAG in ACR $ACR_NAME..."
              if az acr repository show-tags -n "$ACR_NAME" --repository "$REPO" --query "[?@=='$SHA_TAG']|length(@)" -o tsv | grep -q '^1$'; then
                DEPLOY_TAG="$SHA_TAG"
              else
                echo "SHA tag not found. Falling back to '$FALLBACK'."
                DEPLOY_TAG="$FALLBACK"
              fi

              echo "##vso[task.setvariable variable=DEPLOY_TAG]$DEPLOY_TAG"
              echo "##vso[task.setvariable variable=DEPLOY_IMAGE]$registry/$REPO:$DEPLOY_TAG"
              echo "Deploying image: $registry/$REPO:$DEPLOY_TAG"

        # RBAC sanity
        - task: Kubernetes@1
          displayName: 'RBAC: can-i patch deployment'
          inputs:
            connectionType: 'Kubernetes Service Connection'
            kubernetesServiceEndpoint: '$(SC_AKS)'
            namespace: '${{ parameters.deployNamespace }}'
            command: auth
            arguments: 'can-i patch deployment -n ${{ parameters.deployNamespace }}'

        # Apply manifest (keeps spec in Git) and inject image
        - task: KubernetesManifest@1
          displayName: 'Apply manifest (if enabled)'
          condition: and(succeeded(), eq(${{ parameters.applyManifest }}, true))
          inputs:
            action: 'deploy'
            kubernetesServiceConnection: '$(SC_AKS)'
            namespace: '${{ parameters.deployNamespace }}'
            manifests: |
              ${{ parameters.manifestPath }}
            containers: |
              $(DEPLOY_IMAGE)
            rolloutStatusTimeout: '600'

        # Force the image (idempotent, guarantees rollout even if manifest was unchanged)
        - task: Kubernetes@1
          displayName: 'Force set image on deployment'
          inputs:
            connectionType: 'Kubernetes Service Connection'
            kubernetesServiceEndpoint: '$(SC_AKS)'
            namespace: '${{ parameters.deployNamespace }}'
            command: set
            arguments: >
              image deployment/$(K8S_DEPLOYMENT)
              $(CONTAINER_NAME)=$(DEPLOY_IMAGE)

        - task: Kubernetes@1
          displayName: 'Wait for rollout'
          inputs:
            connectionType: 'Kubernetes Service Connection'
            kubernetesServiceEndpoint: '$(SC_AKS)'
            namespace: '${{ parameters.deployNamespace }}'
            command: rollout
            arguments: 'status deployment/$(K8S_DEPLOYMENT) --timeout=900s'

        # Diagnostics on failure
        - task: Bash@3
          displayName: 'Diagnostics (on failure)'
          condition: failed()
          inputs:
            targetType: inline
            script: |
              set -x
              NS='${{ parameters.deployNamespace }}'
              kubectl describe deploy/$(K8S_DEPLOYMENT) -n "$NS" || true
              kubectl get rs -n "$NS" -l app=virec-web-app -o wide || true
              kubectl get pods -n "$NS" -l app=virec-web-app -o wide || true
              POD="$(kubectl get pods -n "$NS" -l app=virec-web-app -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)"
              if [ -n "$POD" ]; then
                kubectl describe pod "$POD" -n "$NS" || true
                kubectl logs "$POD" -n "$NS" --tail=200 || true
              fi
              kubectl get events -n "$NS" --sort-by=.metadata.creationTimestamp | tail -n 100 || true
